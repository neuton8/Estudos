<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CE_3_2_por vb</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
</head>

<body class="stackedit">
  <div class="stackedit__html"><h1 id="estudo-de-caso-3.2">Estudo de caso 3.2</h1>
<img src="https://drive.google.com/uc?export=view&amp;id=1du2bbjAM4VMziHc2jl9Etk7q26IxuLyy">
<h2 id="limites-de-decisão---redes-neurais-profundas">Limites de decisão - Redes neurais profundas</h2>
<h3 id="instruções-de-execução">Instruções de execução</h3>
<blockquote>
<h4 id="google-colab-recomendado">Google Colab (recomendado)</h4>
<p>Caso queira executar o estudo de caso em Python sem precisar instalar um programa/arquivo em seu computador, faça o que está descrito a seguir:</p>
<ol>
<li>Acesse o seguinte <em>notebook</em> do Google Colab: <a href="https://drive.google.com/file/d/1roN4bRChoCFurV2bkrqirce6YjU1Qmee/view?usp=sharing">CE_3.2.ipynb</a></li>
<li>Escolha a opção “Abrir com Google Colaboratory”</li>
<li>Copie o <em>notebook</em> em seu próprio Google Drive (pode-se executar o código sem realizar esta etapa porém as alterações não ficarão salvas se parte do código for modificado) --&gt; “Copiar no Drive”</li>
</ol>
</blockquote>
<hr>
<h3 id="descrição">Descrição</h3>
<p>Deve-se admitir que a criação de estruturas com camadas de perceptrons é um mistério. Que tipos de padrões as redes neurais profundas conseguem reconhecer? E de que forma elas são mais potentes do que um único perceptron? Neste estudo de caso, essas questões serão exploradas em duas dimensões, para que você possa visualizá-las facilmente. O que acontece em dimensões superiores é muito mais complexo e é uma área de contínua investigação.</p>
<h3 id="primeira-parte-quando-os-perceptrons-funcionam-e-quando-não">Primeira parte: Quando os perceptrons funcionam e quando não?</h3>
<p>O exemplo sobre a classificação de peixes, no qual se baseia este estudo de caso, foi adaptado do livro <a href="https://www.wiley.com/en-us/Pattern+Classification%2C+2nd+Edition-p-9780471056690"><em>Pattern Classification</em></a> de Richard O. Duda, Peter E. Hart e David G. Stork.</p>
<p>Imagine que uma fábrica de embalagem de peixes deseja automatizar, de acordo com a espécie, o processo de classificação dos peixes que chegam em uma esteira transportadora. Como projeto piloto, decide-se separar o robalo do salmão através de sensores ópticos. Uma câmera é usada para tirar fotos e, após o pré-processamento, são obtidas variáveis dos peixes, como comprimento, tonalidade, largura, número e forma das nadadeiras, etc…  Depois de alguns exemplos, foi observado que bastava classificar as duas espécies de peixes apenas com base no comprimento e na tonalidade.</p>
<p>A seguir, você deverá encontrar um bom classificador de peixes, considerando o conjunto de dados composto de amostras de peixes rotulados. Especificamente, para cada peixe, são coletados o comprimento e a tonalidade como um vetor em <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>. O vetor é normalizado subtraindo o comprimento médio e a tonalidade média dos peixes. O conjunto de dados pode ser visualizado no sistema de coordenadas bidimensional mostrado na Figura 1. Encontre a linha que passa pela origem e separa os dois tipos de peixes. Você consegue escrever os pesos de um perceptron, cujo limiar é definido como zero, que separam os dois tipos de peixe?</p>
<figure>
	<img src="https://drive.google.com/uc?export=view&amp;id=1ct7ywK1UlqRB5TOyVZxSfS9QJaC0_-KX" width="75%">
	<figcaption><b>Figura 1.</b></figcaption>
</figure>
<p>Também foi coletado outro conjunto de peixes rotulados, conforme mostrado na Figura 2. Você ainda consegue encontrar uma linha que passa pela origem e separa os dois tipos? E uma linha que não passa necessariamente pela origem? Você consegue escrever os pesos de um perceptron que podem fazer isso? É necessário um limite diferente de zero ou você consegue isso com um limite definido como zero?</p>
<figure>
	<img src="https://drive.google.com/uc?export=view&amp;id=12UKUWRIP7ILBAUU-8giUhSXhlxtvxlWT" width="75%">
	<figcaption><b>Figura 2.</b></figcaption>
</figure>
<p>Agora, para o seguinte conjunto de dados, você consegue encontrar uma linha que separa os dois tipos de peixes? Existe algum perceptron que possa fazer isso? Por que sim ou por que não?</p>
<figure>
	<img src="https://drive.google.com/uc?export=view&amp;id=1E45ZDhRAt2xtOdr0wbinQpYGVlCmE9B3" width="75%"> 
	<figcaption><b>Figura 3.</b></figcaption>
</figure>
<p>Consegue pensar em algum exemplo diferente de pontos em <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> rotulados com +1 e -1 que não poderia separar nenhum perceptron?</p>
<h3 id="segunda-parte-redes-neurais-com-duas-camadas">Segunda parte: redes neurais com duas camadas</h3>
<p>Esta parte explorará por que a adição de mais camadas dá mais poder expressivo ao perceptron. Ou seja, um perceptron multicamadas pode ter um limite de decisão muito mais complexo do que um único perceptron.</p>
<p>Uma maneira simples de determinar o limite de decisão de uma função complexa é avaliar a função em uma grade e colorir cada vértice de acordo com o valor da função (consulte a Figura 4). O gráfico a seguir mostra um exemplo do limite de decisão de um perceptron de duas camadas exibido dessa forma. Neste perceptron, é usada a não linearidade sigmoide</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><msup><mi>e</mi><mrow><mi mathvariant="normal">−</mi><mi>x</mi></mrow></msup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\sigma(x)=\frac{1}{1+e^{−x}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 2.09077em; vertical-align: -0.76933em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.32144em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.697331em;"><span class="" style="top: -2.989em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">x</span></span></span></span></span></span></span></span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.76933em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p>
<p>e o perceptron é dado pela expressão:</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mi>s</mi><mi>i</mi><mi>g</mi><mi>n</mi><mi>o</mi></mrow><mo stretchy="false">(</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>σ</mi><mo stretchy="false">(</mo><mi mathvariant="normal">−</mi><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">−</mi><mn>1.5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)=\mathit{signo}(\sigma(x_1)+\sigma(−x_2)−1.5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">g</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">−</span><span class="mord">1</span><span class="mord">.</span><span class="mord">5</span><span class="mclose">)</span></span></span></span></span></span></p>
<p>Observe como o limite de decisão se transforma em não linear.</p>
<figure>
	<img src="https://drive.google.com/uc?export=view&amp;id=1O5uLw9-Fpkg0sdEVHr6qw66ZPVDVlTvY" width="75%">
	<figcaption><b>Figura 4.</b></figcaption>
</figure>
<p>No entanto, esse método simples é bastante cansativo para ser executado manualmente. Mesmo com um computador, torna-se muito trabalhoso quando se trata de grandes dimensões porque há muitos pontos para serem verificados e, também, através desse método, é muito difícil visualizar o que está acontecendo.</p>
<p>Porém, para um caso concreto simples, o limite de decisão pode ser encontrado sem precisar verificar uma grade de pontos. Você consegue determinar o limite de decisão da rede neural abaixo com duas camadas e com a não linearidade dada pela chamada <em>Unidade Linear Retificada</em> (ReLU)? A função ReLU é definida como</p>
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="normal">R</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">L</mi><mi mathvariant="normal">U</mi></mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{ReLU}(x)=max(x,0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathrm">R</span><span class="mord mathrm">e</span><span class="mord mathrm">L</span><span class="mord mathrm">U</span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span></span></span></p>
<p>Agora para <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">x=(x_1, x_2)\in \mathbb{R}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.43056em; vertical-align: 0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>, considere a seguinte rede:<br>
<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mi>s</mi><mi>i</mi><mi>g</mi><mi>n</mi><mi>o</mi></mrow><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">R</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">L</mi><mi mathvariant="normal">U</mi></mrow><mo stretchy="false">(</mo><mi mathvariant="normal">−</mi><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mrow><mi mathvariant="normal">R</mi><mi mathvariant="normal">e</mi><mi mathvariant="normal">L</mi><mi mathvariant="normal">U</mi></mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mi mathvariant="normal">−</mi><mn>0.1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)=\mathit{signo}(\mathrm{ReLU}(−x_1)+\mathrm{ReLU}(x_2)−0.1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord mathit">g</span><span class="mord mathit">n</span><span class="mord mathit">o</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">R</span><span class="mord mathrm">e</span><span class="mord mathrm">L</span><span class="mord mathrm">U</span></span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathrm">R</span><span class="mord mathrm">e</span><span class="mord mathrm">L</span><span class="mord mathrm">U</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.301108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">−</span><span class="mord">0</span><span class="mord">.</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></span></p>
<p>Qual o limite de decisão?</p>
<blockquote>
<p><strong>Dica</strong>: Observe que cada um dos dois perceptrons depende apenas de uma das coordenadas, comprimento ou tonalidade. Tente fixar uma das coordenadas de um ponto e ver o que acontece quando os valores da outra coordenada variam. Quanto a saída <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span> muda?</p>
</blockquote>
<p>Observe a solução no <em>notebook</em> do Python associado a este estudo de caso.</p>
<h3 id="terceira-parte-o-poder-da-profundidade">Terceira parte: O poder da profundidade</h3>
<p>Agora que você consegue controlar alguns tipos de padrões que podem ser reconhecidos com uma rede neural de duas camadas de profundidade e também alguns tipos de padrões que não podem ser reconhecidos por um único perceptron , podemos explorar os benefícios da profundidade. Vamos juntar o que aprendemos. Com as duas partes anteriores, você consegue pensar em um exemplo de um conjunto de pontos em <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi mathvariant="double-struck">R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\mathbb{R}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.814108em; vertical-align: 0em;"></span><span class="mord"><span class="mord"><span class="mord mathbb">R</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.814108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span> com rótulos de robalo/salmão atribuídos para que possam ser separados por um perceptron de duas camadas, mas não por um único perceptron?</p>
<p>Uma pergunta que surge naturalmente é: as redes neurais com uma profundidade de três são mais potentes do que as de duas? Esta é uma questão muito mais sutil do que aquilo que exploramos aqui. Para iniciantes, quando a profundidade de dois era comparada à de um, havia padrões que a profundidade de um não conseguia reconhecer. No entanto, todos os padrões podem ser reconhecidos com uma profundidade de rede de dois. Qual a armadilha aqui? Que você pode precisar de uma enorme rede para conseguir isso. Supõe-se que existem padrões que podem ser reconhecidos com redes pequenas com profundidade de três que não podem ser reconhecidos com redes pequenas com profundidade de dois. É algo que parece ser verdade, mas que ninguém sabe como demonstrar!</p>
<hr>
<img src="https://drive.google.com/uc?export=view&amp;id=1du2bbjAM4VMziHc2jl9Etk7q26IxuLyy">
<p>©2021 Massachusetts Institute of Technology</p>
<!--stackedit_data:&#10;eyJoaXN0b3J5IjpbLTE4Nzc5MTY5MzYsOTAxMTIzNjgxLDEwMD&#10;AwNTQxNDIsLTE4NTIxNzA2MSwtMTg0NDU2NTQ1NSwtNjY4NjE4&#10;ODcxLC0xNTQ3ODM2NTM0LDczMDk5ODExNl19&#10;-->
</div>
</body>

</html>
